import matplotlib.pyplot as plt
import numpy as np
import os
import pickle

from matplotlib import colorbar, colormaps, colors, widgets
from matplotlib.transforms import Bbox
from typing import Callable

import hotspice
xp = hotspice.xp
import thesis_utils

from thermally_active_ASI_old import get_thermal_mm # Need an old version for this, otherwise would get a bunch of KeyErrors which I don't want to tackle right now
from signals import *


NO_TRAIN_FIG_FRAC = 0.525 # Fraction of figure to save when training should be omitted


## Create custom Sweep class to generate the relevant type of experiments
class Sweep_SignalTf_ThermalOOPSquare(hotspice.experiments.Sweep):
    """ This is a parameter sweep for a SignalTransformationExperiment.
        The inputter and readout are a UniformInputter and a RegionalOutputreader, and can not
        be changed by the user because these types are necessary for the signal transformation.
        NOTE: The average energy barrier is kept constant at 20 kBT.
    """
    def __init__(self, groups=None, **kwargs):
        # WARN: E_B_std will cause random variation throughout the sweep, one can keep the randomness without this in-sweep variation by using E_B_std=0 and defining E_B directly as randomized once when initializing the sweep
        kwargs = {
            'DD_ratio': 2.5, 'E_B_std': 0.05, 'E_B_ratio': 20, 'J_ratio': 0, 'gradient': 0.1,
            'size': 20, 'size_y': None, 'DD_exponent': -3, 'T_factor': 1,
            'signal': Signals.SINE, 'target': Signals.SAW, 'offset': 0,
            'frequency': 8e2, 'magnitude': 3.4e-4, 'magnitude_min_frac': None, 'magnitude_min': 0,
            'res_x': None, 'res_y': None, 'use_constant': True
            } | kwargs # Dict with all parameter values as tuples of length 1 or greater
        names = {
            'DD_ratio': "NN DD interaction", 'E_B_ratio': "Energy barrier", 'E_B_std': "Energy barrier standard deviation", 'gradient': r"Property gradient $\Gamma$",
            'size': "# magnets along each axis $N_x = N_y$", 'DD_exponent': "Exponent of DD interaction", 'T_factor': "Temperature",
            'signal': "Input signal", 'target': "Target signal", 'offset': "Input offset w.r.t. target",
            'frequency': "Input frequency $f$", 'magnitude': "Input 1 field magnitude $B_1$", 'magnitude_min_frac': "Input 0/1 field magnitude fraction", 'magnitude_min': "Input 0 field magnitude $B_0$",
            'res_x': "# readout nodes along x-axis", 'res_y': "# readout nodes along y-axis", 'use_constant': "Constant included in OLS"
        }
        units = {'DD_ratio': "$k_BT$", 'E_B_ratio': "$k_BT$", 'T_factor': "$\cross$300K", 'offset': "periods", 'frequency': "Hz", 'magnitude': "T", "magnitude_min": "T"}
        super().__init__(groups=groups, names=names, units=units, **kwargs)

    def create_experiment(self, params: dict) -> hotspice.experiments.TaskAgnosticExperiment:
        if params['magnitude_min_frac'] is not None:
            params['magnitude_min'] = params['magnitude_min_frac']*params['magnitude']
        mm = get_thermal_mm(E_B_ratio=params['E_B_ratio'], DD_ratio=params['DD_ratio'], J_ratio=params['J_ratio'], E_B_std=params['E_B_std'], gradient=params['gradient'], size=params['size'], size_y=params['size_y'], DD_exponent=params['DD_exponent'], T_factor=params['T_factor'])
        experiment = SignalTransformationExperiment(mm, params['signal'], params['target'], params['frequency'], (params['magnitude_min'], params['magnitude']), offset=params['offset'], res_x=params['res_x'], res_y=params['res_y'], use_constant=params['use_constant'])
        return experiment
    
    # Plotting function copied from hotspice.experiments and adjusted for the specifics of thesis figures
    def plot(self, summary_files, check=True, param_x=None, param_y=None, unit_x=None, unit_y=None, transform_x=None, transform_y=None,
             transform_z=None, name_x=None, name_y=None, names_z: list|str = None,
             logarithmic_vars: list[str] = None, colormap: str = None, title=None, show_vertical_grid=False,
             save=True, plot=True, metrics: list[str] = None, dpi: float = 600, details: list = [],
             fig_width: float = None, fig_height: float = None, panels_x: float = None, panels_y: float = None,
             savefig_kwargs: dict = None, label_axes: list = None):
        """ Generic function to plot the results of a sweep in a general way.
            @param summary_files [list(str)]: list of path()s to file(s) as generated by `Sweep.load_results()`.
                If more than one such file is passed on, multiple sweeps' metrics are averaged. This is for example
                useful when there is a random energy barrier that needs to be sampled many times for a correct distribution.
            @param param_x, param_y [str] (None): the column names of the sweeped parameters
                to be put on the X- and Y-axis, respectively.
            @param metrics [list(str)] (None): if specified, only the metrics in this list are plotted (i.e., the
                keys in `experiment.get_plot_metrics()`). If not specified, all possible metrics are plotted.
            @param check [bool] (True): if False, the time-consuming check that ensures correct averaging is omitted.
            # TODO: for ND (N>2) sweeps, we need a way of specifying the values of the N-2 or N-1 unplottable parameters (e.g. by adding <other_params> dict)
            # TODO: Check if this function works for 1D sweeps, or higher than 3D
            # TODO: do something about transform_x and transform_y, they feel out-of-place right now
            # TODO: revisit `save=True`, `plot=True`, `title=None`...
            # TODO: is there a way to somehow detect the units of the axes without explicitly passing them to `name_x` and `name_y`?
        """
        if isinstance(summary_files, str):
            if os.path.isfile(summary_files):
                summary_files = [summary_files] # We use an iterable of strings, just in case they need to be averaged.
            else: # is dir
                summary_files = [os.path.join(summary_files, file) for file in os.listdir(summary_files) if (os.path.isfile(os.path.join(summary_files, file)) and file.endswith('.json'))]

        ## Default arguments
        colnames = [group[0] for group in self.groups] # For each group, just take the first parameter to show values/name
        experiment: type[hotspice.experiments.Experiment] = type(self.get_iteration(0)[1]) # Gets the class type of the generated experiments
        if transform_x is None: transform_x = lambda x: x
        if transform_y is None: transform_y = lambda y: y
        if transform_z is None: transform_z = lambda z: z
        metrics_dict: dict[str, hotspice.experiments.SweepMetricPlotparams] = experiment.get_plot_metrics()
        if metrics is not None: # If it is None, we just ignore this and plot them all
            metrics_dict = {k: v for k, v in metrics_dict.items() if k in metrics}
        n = len(metrics_dict) # Number of metrics

        if param_x is None:
            param_x = colnames[0] # There will be at least one colname, otherwise this is not a sweep
        if param_y is None:
            for colname in colnames:
                if (colname not in metrics_dict.keys()) and (colname != param_x):
                    param_y = colname
                    break
        is_2D = param_y is not None

        ## Units and names
        if unit_x is None: unit_x = self.units[param_x]
        if unit_y is None: unit_y = self.units[param_y]
        if name_x is None: name_x = self.names[param_x]
        if name_y is None: name_y = self.names[param_y]

        ## Load data and extract metrics
        all_metrics = [0 for _ in range(n)]
        for summary_file in summary_files:
            data = hotspice.utils.Data.load(summary_file)
            if is_2D:
                df = data.df.sort_values([param_x, param_y], ascending=[True, True])
                y_vals = df[param_y].unique()
            else:
                df = data.df.sort_values([param_x], ascending=[True])
            x_vals = df[param_x].unique()
            metrics = [[] for _ in range(n)]
            if check:
                for val_x, dfi in data.df.groupby(param_x):
                    metrics_i = [[] for _ in range(n)]
                    if is_2D:
                        for val_y, dfj in dfi.groupby(param_y):
                            data_j = data.mimic(dfj)
                            for i, metric_params in enumerate(metrics_dict.values()):
                                metrics_i[i].append(metric_params.data_extractor(data_j).iloc[0])
                    else:
                        data_i = data.mimic(dfi)
                        for i, metric_params in enumerate(metrics_dict.values()):
                            metrics_i[i] = metric_params.data_extractor(data_i).iloc[0]
                    for i, _ in enumerate(metrics):
                        metrics[i].append(metrics_i[i])
            else:
                for i, metric_params in enumerate(metrics_dict.values()):
                    metrics[i] = np.asarray(metric_params.data_extractor(data)).reshape(len(x_vals), -1)
                    if param_x != data.df.columns[0]:
                        metrics[i] = metrics[i].T
                        if param_x != data.df.columns[1] or vary_name != data.df.columns[0]:
                            raise ValueError("Parameters to be plotted are not the first two columns in dataframe. Use check=True in sweep.plot().")
            for i, metric in enumerate(metrics):
                all_metrics[i] += np.asarray(metric)
        all_metrics = [metric/len(summary_files) for metric in all_metrics]
        for i, metric_key in enumerate(metrics_dict.keys()): # Not flawless, but mostly ok when using SweepMetricPlotParams
            data.df[metric_key] = all_metrics[i].reshape(-1)

        ## PLOTTING
        if colormap is None: colormap = 'viridis'
        cmap = colormaps[colormap].copy()
        # cmap.set_under(color='black')
        hotspice.plottools.init_style()

        if logarithmic_vars is None: logarithmic_vars = ['frequency']
        xscale = 'log' if param_x in logarithmic_vars else 'linear'
        yscale = 'log' if param_y in logarithmic_vars else 'linear'

        corners = lambda arr: np.asarray([(3*arr[0] - arr[1])/2] + [(arr[i+1] + arr[i])/2 for i in range(len(arr)-1)] + [3*arr[-1]/2 - arr[-2]/2])
        x_vals = transform_x(x_vals)
        x_lims = corners(np.log10(x_vals) if xscale == 'log' else x_vals)
        if xscale == 'log': x_lims = 10**x_lims
        if is_2D:
            y_vals = transform_y(y_vals)
            y_lims = corners(np.log10(y_vals) if yscale == 'log' else y_vals)
            if yscale == 'log': y_lims = 10**y_lims

        # If some plots are going to be omitted, then <n> should be recalculated
        n = sum([not params.omit_if_constant or not np.all(np.isclose(all_metrics[i], all_metrics[i][0,0])) for i, params in enumerate(metrics_dict.values())])

        # Plot the metrics
        if panels_y is None and panels_x is None:
            def get_divisor(i): # https://stackoverflow.com/a/75113741
                if n < 4: return 1
                divisor = 1
                for i in range(2, n):
                    if i*i == n: return i
                    if i*i < n and n % i == 0: divisor = i
                    if i*i > n: return divisor
                return -1 # Should never be reached
            panels_y = get_divisor(n)
            panels_x = int(n/panels_y)
        elif panels_x is not None:
            panels_y = int(n/panels_x)
        elif panels_y is not None:
            panels_x = int(n/panels_y)
            
        if fig_width is None: fig_width = 3.3*panels_x
        if fig_height is None: fig_height = fig_width/panels_x*panels_y*0.8
        fig: plt.Figure
        fig, axes = plt.subplots(panels_y, panels_x, figsize=(fig_width, fig_height), sharex=True, sharey=True)
        label_x = name_x if unit_x is None else f"{name_x} [{unit_x}]"
        if names_z is None:
            names_z = [None]*n
        elif isinstance(names_z, str): # Just add it at the end
            names_z = [None]*(n-1) + [names_z]
        else:
            names_z = names_z + [None]*(n - len(names_z))
        if is_2D:
            label_y = name_y if unit_y is None else f"{name_y} [{unit_y}]"
            X, Y = np.meshgrid(x_lims, y_lims)
            for i, (metric_key, params) in enumerate(metrics_dict.items()):
                Z = np.transpose(all_metrics[i])
                if params.omit_if_constant and np.all(np.isclose(Z, Z[0,0])): continue
                Z = transform_z(Z)
                ax: plt.Axes = axes.flat[i]
                ax.set_xscale(xscale)
                ax.set_yscale(yscale)
                ax.set_xlim(np.min(x_lims), np.max(x_lims))
                ax.set_ylim(np.min(y_lims), np.max(y_lims))
                if (i % panels_x) == 0: ax.set_ylabel(label_y)
                else: ax.tick_params('y', labelleft=False) # Only decorate y-axis on leftmost subplot
                if (i // panels_x) == panels_y - 1: ax.set_xlabel(label_x)
                else: ax.tick_params('x', labelbottom=False) # Only decorate y-axis on leftmost subplot
                ax.set_title(params.full_name)
                vmin = params.min_value(data) if isinstance(params.min_value, Callable) else params.min_value
                vmax = params.max_value(data) if isinstance(params.max_value, Callable) else params.max_value
                if vmin is None: vmin = np.min(Z)
                if vmax is None: vmax = np.max(Z)
                im = ax.pcolormesh(X, Y, Z, cmap=cmap, vmin=vmin, vmax=vmax, shading='flat', linewidth=0, rasterized=True, zorder=0) # OPT: can use vmin and vmax, but not without a Metric() class, which I think would lead us a bit too far once again
                im.set_edgecolor('face')
                c: colorbar.Colorbar = plt.colorbar(im) # OPT: can use extend='min' for nice triangle at the bottom if range is known
                if params.is_integer: c.ax.yaxis.get_major_locator().set_params(integer=True) # only integer colorbar labels
                if len(params.contours) > 0:
                    contours = [transform_z(contour(data)) for contour in params.contours]
                    ax.contour(*np.meshgrid(x_vals, y_vals), Z, contours, colors='k')
                    for contour in contours: c.ax.axhline(contour, color='k') # Contour is plotted with colormap colors
                if names_z[i] is not None:
                    c.ax.set_ylabel(names_z[i], rotation=270, labelpad=12 if vmax < 100 else 6)
                if show_vertical_grid:
                    if xscale == "log": low, high = int(np.min(np.log10(x_lims))), int(np.max(np.log10(x_lims))) + 1
                    else: low, high = int(np.min(x_lims)), int(np.max(x_lims)) + 1
                    for i in range(low, high+1):
                        ax.axvline(x=(10**i if xscale == "log" else i), ymin=y_lims[0], ymax=y_lims[-1], color='k', linestyle=':', linewidth=1)
                
                # marker_labels = ['Ⅰ', 'Ⅱ', 'Ⅲ', 'Ⅳ', 'Ⅴ']
                marker_labels = ['(i)', '(ii)', '(iii)', '(iv)', '(v)']
                for i, detail in enumerate(details):
                    x = transform_x(data.df[param_x][detail])
                    y = transform_y(data.df[param_y][detail])
                    # Draw box and text
                    normalised_metric = (data.df[metric_key][detail] - vmin)/(vmax - vmin)
                    cmapcolhsv = colors.rgb_to_hsv(colors.to_rgb(cmap(normalised_metric)))
                    color = "white" if cmapcolhsv[-1] < 0.5 else "black"
                    ax.annotate(marker_labels[i], (x, y), color=color, va='center_baseline', ha='center',
                        weight='bold', fontproperties='DejaVu Sans', fontsize=12, annotation_clip=False)
        else:
            ax = fig.add_subplot(1, 1, 1)
            for i, params in enumerate(metrics_dict.values()):
                Z = all_metrics[i]
                if params.omit_if_constant and np.all(np.isclose(Z, Z[0,0])): continue
                ax.set_xscale(xscale)
                ax.set_xlabel(label_x)
                ax.set_ylabel("Reservoir metric")
                ax.plot(x_vals, Z, label=params.full_name)

        if title is not None: plt.suptitle(title)
        multi = widgets.MultiCursor(fig.canvas, list(axes.flat), color='black', lw=1, linestyle='dotted', horizOn=True, vertOn=True) # Assign to variable to prevent garbage collection
        fig.tight_layout()
        if "bbox_inches" in savefig_kwargs.keys(): fig.subplots_adjust(wspace=0.3)
        for i, ax in enumerate(axes.flat):
            if label_axes is not None:
                if label_axes[i] is not None:
                    thesis_utils.label_ax(ax, label_axes[i], offset=(-0.2 if i == 0 else 0, 0.1), va="baseline", ha="right")

        if save:
            if len(summary_files) > 1:
                save_path = os.path.splitext(os.path.join(os.path.dirname(summary_files[0]), "averaged"))[0]
            else:
                save_path = os.path.splitext(summary_files[0])[0]
            for ext in ('.pdf', '.png', '.svg'):
                savefig_kwargs = dict(dpi=dpi, transparent=True) | savefig_kwargs
                hotspice.plottools.save_plot(save_path, ext=ext, **savefig_kwargs) # Default dpi is 100, so save at higher res
        if plot:
            plt.show()
        plt.close()
    
    def plot_details(self, details: list, N_cycles: int = None, show_train=True, show_signal=True, samples_per_period=None, fig_height=None, outdir=None, experiment_run_kwargs: dict=None):
        if fig_height is None: fig_height = thesis_utils.page_width/10 + thesis_utils.page_width/6*len(details)
        fig, axes = plt.subplots(len(details), 2, figsize=(thesis_utils.page_width, fig_height))
        axes = axes.reshape(-1, 2)
        
        ## Plot font sizes
        fontsize_header = thesis_utils.fs_medium
        fontsize_axes = thesis_utils.fs_small
        fontsize_legend = thesis_utils.fs_small
        alpha_signal, alpha_target = 0.5, 1.0
        
        for row, detail in enumerate(details):
            ## Load experiment, or create and save experiment
            exp: SignalTransformationExperiment = self.get_iteration(detail)[1]
            print(self.get_iteration(detail)[0] | self.constants)
            filename = os.path.join(outdir, f"detail{detail}.pkl")
            if os.path.exists(filename):
                with open(filename, 'rb') as infile:
                    d = pickle.load(infile)
                    exp.N, exp.t, exp.signal_values, exp.target_values, exp.readout_values = d["N"], d["t"], d["signal_values"], d["target_values"], d["readout_values"]
            else:
                exp.run(**experiment_run_kwargs)
                with open(filename, 'wb') as outfile:
                    d = {"N": exp.N, "t": exp.t, "signal_values": exp.signal_values, "target_values": exp.target_values, "readout_values": exp.readout_values}
                    pickle.dump(d, outfile)
            exp.calculate_all()
            
            ## Determine the best-looking part of the data to show in the plot
            if samples_per_period is None: samples_per_period = np.argmax((exp.t - np.min(exp.t)) >= 1/exp.frequency)
            N_idx = np.argmax((exp.t - np.min(exp.t)) >= (N_cycles*.8)/exp.frequency) # Number of indices per N_cycles*0.8 (legend hides 20% of plot)
            N_idx_full = np.argmax((exp.t - np.min(exp.t)) >= N_cycles/exp.frequency) # Number of indices per N_cycles (to know the full plot length)
            offset = int(samples_per_period/7)
            # Train set:
            MSEs = [exp.MSE(exp.fit_reservoir[i:i+N_idx], exp.target_train[i:i+N_idx]) for i in range(exp.target_train.size - N_idx_full)]
            best_start_idx = np.argmin(MSEs[offset::samples_per_period])*samples_per_period + offset
            train_slice = (best_start_idx, best_start_idx + N_idx_full)
            # Test set:
            MSEs = [exp.MSE(exp.prediction_reservoir[i:i+N_idx], exp.target_test[i:i+N_idx]) for i in range(exp.target_test.size - N_idx_full)]
            best_start_idx = np.argmin(MSEs[offset::samples_per_period])*samples_per_period + offset + exp.target_train.size
            test_slice = (best_start_idx, best_start_idx + N_idx_full)
            
            ## Draw the plots
            t_rescaled, t_unit = hotspice.utils.appropriate_SIprefix(exp.t)
            t_scale = 10**hotspice.utils.SIprefix_to_magnitude[t_unit]
            
            ax1: plt.Axes = axes[row, 0]
            thesis_utils.label_ax(ax1, row+1, roman=True, offset=(-0.14, 0), ha="right", va="top")
            if row == 0 and show_train: ax1.set_title(f"Test set", fontsize=fontsize_header)
            ax1.set_xlabel(f"Time ({t_unit}s)", fontsize=fontsize_axes, labelpad=-0.06)
            ax1.set_ylim([-0.1, 1.1])
            t = exp.get_test(t_rescaled)
            if N_cycles is not None:
                ax1.set_xlim(exp.t[test_slice[0]]/t_scale, exp.t[test_slice[1]]/t_scale)
                # ax1.set_xlim([np.min(t), min(np.max(t), np.min(t) + N_cycles/self.frequency/t_scale)])
            line_target, = ax1.plot(t, exp.get_test(exp.target_values), "k--", alpha=alpha_target)
            line_input_pred, = ax1.plot(t, exp.prediction_rawinput, "r", alpha=0.5)#, label=f"{1/exp.MSE_rawinput:.2f}")
            if row == 0: line_input_pred.set_label(f"{1/exp.MSE_rawinput:.2f}")
            line_reservoir, = ax1.plot(t, exp.prediction_reservoir, "dodgerblue", label=f"{1/exp.MSE_reservoir:.2f}")
            if show_signal: line_input, = ax1.plot(t, exp.signal_test, "k:", alpha=alpha_signal)
            ax1.legend(title=r"1/MSE", fontsize=fontsize_legend, loc='lower right', ncol=1, title_fontproperties={'weight':'bold', 'size': fontsize_legend-2}, handlelength=1, handletextpad=0.4)
            ax1.tick_params(axis='both', labelsize=fontsize_axes)
            ax1.xaxis.set_major_locator(plt.MaxNLocator(5))
            
            ax2: plt.Axes = axes[row, 1]
            if row == 0 and show_train: ax2.set_title(f"Training set", fontsize=fontsize_header)
            ax2.set_xlabel(f"Time ({t_unit}s)", fontsize=fontsize_axes, labelpad=-0.06)
            t = exp.get_train(t_rescaled)
            if N_cycles is not None:
                ax2.set_xlim(exp.t[train_slice[0]]/t_scale, exp.t[train_slice[1]]/t_scale)
                # ax2.set_xlim([np.min(t), min(np.max(t), np.min(t) + N_cycles/self.frequency/t_scale)])
            ax2.set_ylim([-0.1, 1.1])
            ax2.plot(t, exp.get_train(exp.target_values), "k--", alpha=alpha_target)
            ax2.plot(t, exp.fit_rawinput, "r", alpha=0.5)#, label=f"{1/exp.MSE(exp.fit_rawinput, exp.target_train):.2f}")
            ax2.plot(t, exp.fit_reservoir, "dodgerblue", label=f"{1/exp.MSE(exp.fit_reservoir, exp.target_train):.2f}")
            if show_signal: ax2.plot(t, exp.signal_train, "k:", alpha=alpha_signal)
            ax2.legend(title=r"1/MSE", fontsize=fontsize_legend, loc='lower right', ncol=1, title_fontproperties={'weight':'bold', 'size': fontsize_legend-2}, handlelength=1, handletextpad=0.4)
            ax2.tick_params(axis='both', labelsize=fontsize_axes)
            ax2.xaxis.set_major_locator(plt.MaxNLocator(5))
        
        legend = fig.legend(handles=[line_input, line_target, line_input_pred, line_reservoir], labels=["Input signal", "Target", "Optimal input scaling", "ASI reservoir prediction"],
                   loc='upper center', ncol=4 if show_train else 2, fontsize=fontsize_legend)
        fig.tight_layout()
        fig.canvas.draw() # Force a draw so the legend position is updated

        legendpad = 0.25 if show_train else 0.1
        top = (legend.get_window_extent().transformed(fig.dpi_scale_trans.inverted()).y0 - legendpad) / fig.get_size_inches()[1]
        bottom = 0.4 / fig.get_size_inches()[1]

        fig.subplots_adjust(top=top, bottom=bottom, left=0.1, hspace=0.55, wspace=0.2)
        # fig.subplots_adjust(left=0.1, right=0.99)
        bbox_inches = None if show_train else Bbox(points=[[0, 0], [thesis_utils.page_width*NO_TRAIN_FIG_FRAC, fig_height]])
        hotspice.utils.save_results(figures={"details": fig}, outdir=outdir, copy_script=False, bbox_inches=bbox_inches)
        


groups = None
plot_kwargs = {}
## FREQUENCY-MAGNITUDE sweep for Alex' experimental system (11x11 no gradient)
# signal, target = Signals.SINE, Signals.SAW
# plot_kwargs = {"param_x": "frequency",
#                "param_y": "magnitude", "unit_y": "mT", "transform_y": lambda y: y*1e3}
# varx_name, varx_values = "frequency", np.logspace(-2, 7, 55)
# vary_name, vary_values = "magnitude", np.linspace(0e-4, 10e-4, 41)
# size = 11
# gradient = 0
# sweep_kwargs = {
#             'E_B_ratio': 12, 'DD_ratio': 2.5, 'E_B_std': 0.05,
#             'gradient': gradient, 'size': size, 'DD_exponent': -3,
#             'signal': signal, 'target': target, 'offset': 0,
#             'frequency': 8e2, 'magnitude': 3.4e-4, 'magnitude_min': -3.5e-4,
#             'res_x': size, 'res_y': 1, 'use_constant': True,
#             'T_factor': 1
#             } # TODO: magn-magnmin sweep of frozen system because frequency doesn't matter for such high DD_ratio. Do that for a few gradients and 20x20 (always Ao5)
## MAGNITUDE-MAGNITUDE_MIN sweep for baseline system (constant freq: inputs range [0,1] mapped to fields [B_0, B_1])
# signal, target = Signals.SINE, Signals.SAW
# plot_kwargs = {"param_x": "magnitude",     "unit_x": "mT", "transform_x": lambda x: x*1e3,
#                "param_y": "magnitude_min", "unit_y": "mT", "transform_y": lambda y: y*1e3}
# vary_name, vary_values = "magnitude", np.linspace(-0.15, 0.15, 31)
# varx_name, varx_values = "magnitude_min", np.linspace(-0.15, 0.15, 31)
# size = 20
# gradient = 0.1
# sweep_kwargs = {
#             'DD_ratio': 500, 'E_B_ratio': 250, 'E_B_std': 0, 'gradient': gradient, # Extreme case with DD_ratio = 0, just to make sure we are seeing the effect of J here
#             'size': size, 'DD_exponent': -3,
#             'signal': signal, 'target': target, 'offset': 0,
#             'frequency': 1e3, 'magnitude': 3.4e-4,
#             'res_x': size, 'res_y': 1, 'use_constant': True
#             }
## What is the effect of the GRADIENT? (keep frequency constant)
signal, target = Signals.SINE, Signals.SAW
plot_kwargs = {"param_x": "gradient",
               "param_y": "magnitude", "unit_y": "mT", "transform_y": lambda y: y*1e3}
varx_name, varx_values = "gradient", np.linspace(0, 0.8, 21) # NOTE: gradient=1 gives divide-by-zero error
vary_name, vary_values = "magnitude", np.linspace(0e-4, 10e-4, 21)
size = 11
frequency = 150
sweep_kwargs = {
            'DD_ratio': 2.5, 'E_B_std': 0.05, 'gradient': 0,
            'size': size, 'DD_exponent': -3,
            'signal': signal, 'target': target, 'offset': 0,
            'frequency': frequency, 'magnitude': 3.4e-4, 'magnitude_min': -3.5e-4,
            'res_x': size, 'res_y': 1, 'use_constant': True
            }
## What is the influence of SYSTEM SIZE, if the number of READOUT NODES stays the same (or vice versa)?
# signal, target = Signals.SINE, Signals.SAW
# plot_kwargs = {"param_x": "res_x", "param_y": "res_y"}
# varx_name, varx_values = "res_x", np.asarray([1, 2, 3, 4, 6, 9, 12, 18, 36])
# vary_name, vary_values = "res_y", np.asarray([1, 2])
# sweep_kwargs = {
#             'DD_ratio': 2.5, 'E_B_std': 0.05, 'gradient': 0.5,
#             'size': 36, 'DD_exponent': -3,
#             'signal': signal, 'target': target, 'offset': 0,
#             'frequency': 8e2, 'magnitude': 5e-4,
#             'res_x': varx_values, 'res_y': vary_values, 'use_constant': True
#             }
# groups = [("size", "res_x")]
## Original sweep for Alex' system, but now for OTHER TARGET FUNCTIONS
# signal, target = Signals.SINE, Signals.SAW
# plot_kwargs = {"param_x": "frequency",
#                "param_y": "magnitude", "unit_y": "mT", "transform_y": lambda y: y*1e3}
# varx_name, varx_values = "frequency", np.logspace(3, 7.5, 28)
# vary_name, vary_values = "magnitude", np.linspace(0e-4, 10e-4, 21)
# size = 11
# gradient = 0
# sweep_kwargs = {
#             'DD_ratio': 2.5, 'E_B_std': 0.05, 'gradient': gradient,
#             'size': size, 'DD_exponent': -3,
#             'signal': signal, 'target': target, 'offset': 0,
#             'frequency': 8e2, 'magnitude': 3.4e-4,
#             'res_x': size, 'res_y': 1, 'use_constant': True,
#             'T_factor': 2
#             }
## Original sweep for Alex' system, but now for MACKEY-GLASS
# signal, target, offset = Signals.MACKEYGLASS, Signals.MACKEYGLASS, 0.6
# size, gradient = 11, 0.
# magnitude_min = -0.43e-3
# plot_kwargs = {"param_x": "frequency",
#                "param_y": "magnitude", "unit_y": "mT", "transform_y": lambda y: y*1e3}
# varx_name, varx_values = "frequency", np.logspace(-1, 7, 17)
# vary_name, vary_values = "magnitude", np.linspace(magnitude_min, 10e-4, 21)
# sweep_kwargs = {
#             'DD_ratio': 2.5, 'E_B_std': 0.05, 'gradient': gradient,
#             'size': size, 'DD_exponent': -3,
#             'signal': signal, 'target': target, 'offset': offset,
#             'frequency': 800, 'magnitude': 0.34e-3, 'magnitude_min': magnitude_min,
#             'res_x': 11, 'res_y': 1, 'use_constant': True
#             }
## ------------------------------------------------------------------------------------------------------------------
##! EXCHANGE-COUPLED system instead of dipole-coupled (has exponential decay, question is if that vastly improves the results or not)
## Frequency vs. magnitude as usual
# signal, target = Signals.SINE, Signals.SAW
# plot_kwargs = {"param_x": "frequency",
#                "param_y": "magnitude", "unit_y": "mT", "transform_y": lambda y: y*1e3}
# varx_name, varx_values = "frequency", np.logspace(-2, 7, 15)
# vary_name, vary_values = "magnitude", np.linspace(0e-4, 22e-4, 18)
# sweep_kwargs = {
#             'DD_ratio': 0, 'J_ratio': -5, 'E_B_ratio': 30, 'E_B_std': 0.05, 'gradient': 0.5, # Extreme case with DD_ratio = 0, just to make sure we are seeing the effect of J here
#             'size': 22, 'DD_exponent': -3,
#             'signal': signal, 'target': target, 'offset': 0,
#             'frequency': 1, 'magnitude': 1e-3, 'magnitude_min_frac': 0,
#             'res_x': 11, 'res_y': 1, 'use_constant': True
#             }
## MAGNITUDE-MAGNITUDE_MIN sweep for baseline system (constant freq: inputs range [0,1] mapped to fields [B_0, B_1])
# signal, target = Signals.SINE, Signals.SAW
# plot_kwargs = {"param_x": "magnitude", "unit_x": "mT", "transform_x": lambda x: x*1e3,
#                "param_y": "magnitude_min_frac"}
# vary_name, vary_values = "magnitude", np.linspace(0e-4, 22e-4, 18)
# varx_name, varx_values = "magnitude_min_frac", np.linspace(-2, 2, 21)
# sweep_kwargs = {
#             'DD_ratio': 2.5, 'J_ratio': 0, 'E_B_ratio': 20, 'E_B_std': 0.05, 'gradient': 0.5,
#             'size': 11, 'DD_exponent': -3,
#             'signal': signal, 'target': target, 'offset': 0,
#             'frequency': 200, 'magnitude': 1e-3, 'magnitude_min_frac': 0,
#             'res_x': 11, 'res_y': 1, 'use_constant': True
#             }


num_periods = 20 if signal is not Signals.MACKEYGLASS else 200
sweep_kwargs = sweep_kwargs | {varx_name: varx_values, vary_name: vary_values}
sweep = Sweep_SignalTf_ThermalOOPSquare(groups=groups, **sweep_kwargs) #! Do not put in 'if __name__ == "__main__"'! <sweep> must be importable!

if __name__ == "__main__":
    ## Define, parse and clean command-line arguments
    # Usage: python <this_file.py> [-h] [-o [OUTDIR]] [N]
    # NOTE: TO RUN THIS SWEEP ON MULTIPLE GPUs/CPUs, RUN `hotspice.utils.ParallelJobs(<path_to_this_file>)`
    # NOTE: TO ACCESS THIS SWEEP IN PYTHON, DO `sweepscript = __import__(<path_to_this_file>)` TO ACCESS `sweepscript.sweep`
    import argparse # Only parse args if __name__ == "__main__", otherwise args are not meant for this script
    parser = argparse.ArgumentParser(description="Process an iteration of the sweep defined in this file. If not specified, the data in --outdir are summarized into a single data file using calculate_all().")
    parser.add_argument('iteration', metavar='N', type=int, nargs='?', default=None,
                        help="the index of the sweep-iteration to be performed.")
    parser.add_argument('-o', '--outdir', dest='outdir', type=str, nargs='?', default=None)
    args = parser.parse_args()
    outdir = args.outdir if args.outdir is not None else "Task_transformation"

    if args.iteration is not None: # Then one specific iteration of sweep() should be calculated on the first available GPU/CPU.
        save = True
        experiment_run_kwargs = {
            'num_periods': num_periods,
            'samples_per_period': 20,
            'warmup_periods': 5
        }
        sweep.process_single(args.iteration, run_kwargs=experiment_run_kwargs, save_dir=outdir if save else False)


    if args.iteration is None: # This gets run if the file is called without command line arguments
        all_sweeps = []
        
        ## FREQUENCY-MAGNITUDE sweep for Alex' experimental system (11x11 no gradient)
        all_sweeps.append({
            "directory": "freq-magn/baseline",
            "plot_kwargs": {
                "param_x": "frequency",
                "param_y": "magnitude", "unit_y": "mT", "transform_y": lambda y: y*1e3, "name_y": "Input 1 field magnitude $B_1$",
                "logarithmic_vars": ["frequency"]
            },
            "sweep_kwargs": {
                "frequency": np.logspace(-2, 7, 55),
                "magnitude": np.linspace(0e-4, 10e-4, 41),
                "signal": Signals.SINE, "target": Signals.SAW, "offset": 0,
                'DD_ratio': 2.5, 'E_B_std': 0.05,
                'gradient': 0, 'size': 11, 'DD_exponent': -3,
                'magnitude_min': -3.5e-4, 'T_factor': 1,
                'res_x': 11, 'res_y': 1, 'use_constant': True
            },
            "details": [143, 1074, 1976],
            "show_train": True
        })
        
        ## GRADIENT-MAGNITUDE sweep to determine effect of gradient (at a set frequency)
        all_sweeps.append({
            "directory": "grad-magn/freq1",
            "plot_kwargs": {
                "param_x": "gradient", "unit_x": "%", "transform_x": lambda x: x*1e2,
                "param_y": "magnitude", "unit_y": "mT", "transform_y": lambda y: y*1e3, "name_y": "Input 1 field magnitude $B_1$"
            },
            "sweep_kwargs": {
                "gradient": np.linspace(0, 1, 26),
                "magnitude": np.linspace(0e-4, 10e-4, 21),
                "signal": Signals.SINE, "target": Signals.SAW, "offset": 0,
                'DD_ratio': 2.5, 'E_B_std': 0.05,
                'frequency': 1, 'size': 11, 'DD_exponent': -3,
                'res_x': 11, 'res_y': 1, 'use_constant': True
            },
            "details": [281],
            "show_train": False
        })
        
        ## MINIMAL MAGNITUDE vs. MAGNITUDE sweep to determine optimal minimal magnitude (at a set frequency)
        all_sweeps.append({
            "directory": "magn-magnmin/freq100",
            "plot_kwargs": {
                "param_x": "magnitude_min", "unit_x": "mT", "transform_x": lambda x: x*1e3,
                "param_y": "magnitude", "unit_y": "mT", "transform_y": lambda y: y*1e3
            },
            "sweep_kwargs": {
                "magnitude_min": np.linspace(-5e-4, 5e-4, 21),
                "magnitude": np.linspace(-5e-4, 5e-4, 21),
                'DD_ratio': 2.5, 'E_B_std': 0.05, 'gradient': 0, # Extreme case with DD_ratio = 0, just to make sure we are seeing the effect of J here
                'size': 11, 'DD_exponent': -3,
                'signal': Signals.SINE, 'target': Signals.SAW, 'offset': 0,
                'frequency': 100,
                'res_x': 11, 'res_y': 1, 'use_constant': True
            },
            "show_train": False
        })
        
        ## SIZE vs. MAGNITUDE (both res_x==size and res_x=11)
        all_sweeps.append({
            "directory": "size-magn/resx==size",
            "plot_kwargs": {
                "param_x": "size", "name_x": "# readout nodes $p=N_x=N_y$",
                "param_y": "magnitude", "unit_y": "mT", "transform_y": lambda y: y*1e3,
                "label_axes": [0, None]
            },
            "sweep_kwargs": {
                "size": np.linspace(11, 99, 23).astype(int),
                "res_x": np.linspace(11, 99, 23).astype(int),
                "magnitude": np.linspace(0e-4, 10e-4, 21),
                'DD_ratio': 2.5, 'E_B_std': 0.05, 'gradient': 0.1,
                'signal': Signals.SINE, 'target': Signals.SAW, 'offset': 0,
                'frequency': 8e2, 'res_y': 1, 'use_constant': True
            },
            "groups": [("size", "res_x")],
            "show_train": True
        })
        all_sweeps.append({
            "directory": "size-magn/resx=11",
            "plot_kwargs": {
                "param_x": "size",
                "param_y": "magnitude", "unit_y": "mT", "transform_y": lambda y: y*1e3,
                "label_axes": [1, None]
            },
            "sweep_kwargs": {
                "size": np.linspace(11, 99, 23).astype(int),
                "magnitude": np.linspace(0e-4, 10e-4, 21),
                'DD_ratio': 2.5, 'E_B_std': 0.05, 'gradient': 0.1,
                'signal': Signals.SINE, 'target': Signals.SAW, 'offset': 0,
                'frequency': 8e2, "res_x": 11, 'res_y': 1, 'use_constant': True
            },
            "show_train": True
        })
        
        ## OTHER TRANSFORMATIONS
        all_sweeps.append({
            "directory": "freq-magn/target_SINESQ",
            "plot_kwargs": {
                "param_x": "frequency",
                "param_y": "magnitude", "unit_y": "mT", "transform_y": lambda y: y*1e3, "name_y": "Input 1 field magnitude $B_1$",
                "logarithmic_vars": ["frequency"]
            },
            "sweep_kwargs": {
                "frequency": np.logspace(-4, 5, 28),
                "magnitude": np.linspace(0e-4, 10e-4, 21),
                "signal": Signals.SINE, "target": Signals.SINESQUARED, "offset": 0,
                'DD_ratio': 2.5, 'E_B_std': 0.05,
                'gradient': 0, 'size': 11, 'DD_exponent': -3,
                'res_x': 11, 'res_y': 1, 'use_constant': True
            },
            "details": [236],
            "show_train": False
        })
        all_sweeps.append({
            "directory": "freq-magn/target_SQUARE",
            "plot_kwargs": {
                "param_x": "frequency",
                "param_y": "magnitude", "unit_y": "mT", "transform_y": lambda y: y*1e3, "name_y": "Input 1 field magnitude $B_1$",
                "logarithmic_vars": ["frequency"]
            },
            "sweep_kwargs": {
                "frequency": np.logspace(-4, 5, 28),
                "magnitude": np.linspace(0e-4, 10e-4, 21),
                "signal": Signals.SINE, "target": Signals.SQUARE, "offset": 0,
                'DD_ratio': 2.5, 'E_B_std': 0.05,
                'gradient': 0, 'size': 11, 'DD_exponent': -3,
                'res_x': 11, 'res_y': 1, 'use_constant': True
            },
            "details": [113],
            "show_train": False
        })

        ## GO THROUGH ALL THOSE DIRECTORIES
        plot_kwargs_all = { # Individual plot_kwargs get added to these
            "fig_width": thesis_utils.page_width,
            "fig_height": thesis_utils.page_width/2.3,
            "metrics": ["MSE_reservoir", "MSE_reservoir_train"], # Don't use "MSE_rawinput"
            "colormap": "inferno",
            "logarithmic_vars": ["frequency", "res_x", "res_y"]
        }
        
        for arguments in all_sweeps:
            directory = arguments["directory"]
            show_train = arguments.get("show_train", False)
            plot_kwargs_all["names_z"] = "1/MSE" if show_train else ["1/MSE", "1/MSE"]
            plot_kwargs = plot_kwargs_all | arguments["plot_kwargs"]
            sweep_kwargs = arguments.get("sweep_kwargs", {})
            groups = arguments.get("groups")
            details = arguments.get("details", [])
            
            
            sweep = Sweep_SignalTf_ThermalOOPSquare(groups=groups, **sweep_kwargs)
            sweep.plot(os.path.join(os.path.splitext(__file__)[0], directory),
                       details=details, plot=False, check=False,
                       savefig_kwargs=dict() if show_train else dict(bbox_inches=Bbox(points=[[0, 0], [plot_kwargs.get("fig_width")*NO_TRAIN_FIG_FRAC, plot_kwargs.get("fig_height")]])),
                       **plot_kwargs)
            if len(details):
                experiment_run_kwargs = {
                    'num_periods': 20 if sweep_kwargs.get("signal", Signals.SINE) is not Signals.MACKEYGLASS else 100,
                    'samples_per_period': 20,
                    'warmup_periods': 5
                }
                sweep.plot_details(details, N_cycles=4, show_train=show_train, experiment_run_kwargs=experiment_run_kwargs,
                                   outdir=os.path.join(os.path.splitext(__file__)[0], directory))
